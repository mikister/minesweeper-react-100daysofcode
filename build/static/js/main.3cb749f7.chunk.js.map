{"version":3,"sources":["components/Cell.js","App.js","serviceWorker.js","index.js"],"names":["Cell","this","props","cellClick","cellIndex","event","cellFlag","preventDefault","flaged","icon","faFlag","content","faBomb","className","revealed","onClick","onCellClick","bind","onContextMenu","onCellFlag","renderContent","Component","App","setAsyncState","newState","Promise","resolve","setState","a","state","contentGenerated","generateCellContents","cellsRevealed","cellsFlaged","newCellsRevealed","checkCell","cellContents","neighbors","getNeighboringCells","unflagedNeighbors","flagCount","forEach","neighborIndex","ii","length","splice","parseInt","gameOver","bombCount","colsNum","rowsNum","gridRef","React","createRef","cellCount","current","style","setProperty","Array","fill","rowAboveCell","rowBellowCell","push","cells","key","protectedCellIndex","bombsPlaced","newCellContents","neighboringCells","bombCellIndex","Math","floor","random","bombInProtectedArea","bombsAroundCell","toString","newCellsFlaged","ref","renderGrid","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.3cb749f7.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport './Cell.css';\n\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faBomb, faFlag } from '@fortawesome/free-solid-svg-icons'\n\nclass Cell extends Component {\n  onCellClick() {\n    this.props.cellClick(this.props.cellIndex);\n  }\n\n  onCellFlag(event) {\n    this.props.cellFlag(this.props.cellIndex);\n    event.preventDefault();\n  }\n\n  renderContent() {\n    if (this.props.flaged) {\n      return( <FontAwesomeIcon icon={faFlag} /> );\n    }\n    else if(this.props.content === \"\") {\n      return( null );\n    }\n    else if(this.props.content === \"b\") {\n      return( <FontAwesomeIcon icon={faBomb} /> );\n    }\n    else {\n      return( <span>{ this.props.content }</span> );\n    }\n  }\n\n  render() {\n    return(\n      <div\n        className={\n          \"cell \" + \n          (this.props.revealed ? \"cell--revealed \" : \"\") + \n          (this.props.flaged ? \"cell--flaged \" : \"\") \n        }\n        onClick={this.onCellClick.bind(this)}\n        onContextMenu={this.onCellFlag.bind(this)}\n      >\n        { this.renderContent() }\n      </div>\n    );\n  }\n}\n\nexport default Cell;","import React, { Component } from 'react';\nimport './App.css';\n\nimport Cell from \"./components/Cell.js\";\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      cellContents: [],\n      cellsRevealed: [],\n      cellsFlaged: [],\n      bombCount: 30,\n      contentGenerated: false,\n      colsNum: 10,\n      rowsNum: 18,\n    };\n\n    this.gridRef = React.createRef();\n  }\n\n  setAsyncState = (newState) => {\n    return new Promise((resolve) => this.setState(newState, () => resolve()));\n  }\n\n  componentDidMount() {\n    let cellCount = this.state.rowsNum * this.state.colsNum;\n\n    this.gridRef.current.style.setProperty(\"--larger-dimension\", this.state.rowsNum);\n    this.gridRef.current.style.setProperty(\"--smaller-dimension\", this.state.colsNum);\n\n    this.setState({\n      cellContents: Array(cellCount).fill(\"\"),\n      cellsRevealed: Array(cellCount).fill(false),\n      cellsFlaged: Array(cellCount).fill(false),\n    });\n  }\n\n  getNeighboringCells(cellIndex) {\n    var neighbors = [];\n    \n    let cellCount = this.state.rowsNum * this.state.colsNum;\n    let rowAboveCell = cellIndex - this.state.colsNum;\n    let rowBellowCell = cellIndex + this.state.colsNum;\n\n    if (rowAboveCell > 0) {\n      neighbors.push(rowAboveCell);\n\n      if ((cellIndex + 1) % this.state.colsNum !== 1)\n        neighbors.push(rowAboveCell - 1)\n\n      if ((cellIndex + 1) % this.state.colsNum !== 0)\n        neighbors.push(rowAboveCell + 1);\n    }\n\n    if ((cellIndex + 1) % this.state.colsNum !== 1)\n      neighbors.push(cellIndex - 1);\n    if ((cellIndex + 1) % this.state.colsNum !== 0)\n      neighbors.push(cellIndex + 1);\n\n    if (rowBellowCell < cellCount) {\n      neighbors.push(rowBellowCell);\n\n      if ((cellIndex + 1) % this.state.colsNum !== 1)\n        neighbors.push(rowBellowCell - 1);\n      \n      if ((cellIndex + 1) % this.state.colsNum !== 0)\n        neighbors.push(rowBellowCell + 1);\n    }\n\n    return neighbors;\n  }\n\n  renderGrid() {\n    var cells = [];\n\n    for(var cellIndex = 0; cellIndex < (this.state.colsNum * this.state.rowsNum); cellIndex++) {\n      cells.push(\n        <Cell \n          cellClick={this.cellClick.bind(this)} \n          cellFlag={this.cellFlag.bind(this)}\n          content={this.state.cellContents[cellIndex]} \n          revealed={this.state.cellsRevealed[cellIndex]} \n          flaged={this.state.cellsFlaged[cellIndex]}\n          cellIndex={cellIndex} \n          key={cellIndex} \n        />);\n    }\n\n    return cells;\n  }\n\n  generateCellContents(protectedCellIndex=null) {\n    let cellCount = this.state.rowsNum * this.state.colsNum;\n    var bombsPlaced = 0;\n    var newCellContents = Array(cellCount).fill(\"\");\n    var neighboringCells = [];\n\n    while(bombsPlaced < this.state.bombCount) {\n      let bombCellIndex = Math.floor(Math.random() * cellCount);\n\n      if (newCellContents[bombCellIndex] !== \"b\") {\n        if (protectedCellIndex === null) {\n          newCellContents[bombCellIndex] = \"b\";\n          bombsPlaced++;\n        }\n        else {\n          if (bombCellIndex === protectedCellIndex)\n            continue;\n\n          neighboringCells = this.getNeighboringCells(protectedCellIndex);\n          var bombInProtectedArea = false;\n\n          neighboringCells.forEach((neighborIndex) => {\n            if (neighborIndex === bombCellIndex) {\n              bombInProtectedArea = true;\n            }\n          });\n\n          if (bombInProtectedArea) {\n            continue;\n          }\n\n          newCellContents[bombCellIndex] = \"b\";\n          bombsPlaced++;\n        }\n      }\n    }\n\n    for(var cellIndex = 0; cellIndex < cellCount; cellIndex++) {\n      if (newCellContents[cellIndex] === \"b\")\n        continue;\n\n      var bombsAroundCell = 0;\n      neighboringCells = this.getNeighboringCells(cellIndex);\n\n      neighboringCells.forEach((neighborIndex) => {\n        if (newCellContents[neighborIndex] === \"b\") {\n          bombsAroundCell++;\n        }\n      });\n\n      if (bombsAroundCell > 0) {\n        newCellContents[cellIndex] = bombsAroundCell.toString();\n      }\n    }\n\n    return this.setAsyncState({\n      cellContents: newCellContents,\n    });\n  }\n\n  cellFlag(cellIndex) {\n    if (!this.state.cellsRevealed[cellIndex]) {\n      var newCellsFlaged = this.state.cellsFlaged;\n      newCellsFlaged[cellIndex] = !newCellsFlaged[cellIndex];\n  \n      this.setState({\n        cellsFlaged: newCellsFlaged,  \n      });\n    }\n  }\n\n  cellClick = async (cellIndex) => {\n    if (!this.state.contentGenerated) {\n      await this.generateCellContents(cellIndex);\n\n      this.setState({\n        contentGenerated: true,  \n      });\n    }\n\n    if (this.state.cellsRevealed[cellIndex] === false && this.state.cellsFlaged[cellIndex] === false) {\n      var newCellsRevealed = this.state.cellsRevealed;\n      newCellsRevealed[cellIndex] = true;\n      await this.setAsyncState({\n        cellsRevealed: newCellsRevealed,\n      });\n\n      this.checkCell(cellIndex);\n    }\n    else if (this.state.cellsRevealed[cellIndex] === true && this.state.cellContents[cellIndex] !== \"\") {\n      var neighbors = this.getNeighboringCells(cellIndex);\n      var unflagedNeighbors = [...neighbors];\n      var flagCount = 0;\n      \n      \n      neighbors.forEach((neighborIndex) => {\n        if (this.state.cellsFlaged[neighborIndex]) {\n          flagCount++;\n        }\n\n        if (this.state.cellsFlaged[neighborIndex] || this.state.cellsRevealed[neighborIndex]) {\n          for( var ii = 0; ii < unflagedNeighbors.length; ii++){ \n            if ( unflagedNeighbors[ii] === neighborIndex) {\n              unflagedNeighbors.splice(ii, 1); \n            }\n          }\n        }\n      });\n\n      if (flagCount === parseInt(this.state.cellContents[cellIndex])) {\n        unflagedNeighbors.forEach((neighborIndex) => {\n          this.cellClick(neighborIndex);\n        });\n      }\n    }\n  }\n\n  checkCell = async (cellIndex) => {\n    if (this.state.cellContents[cellIndex] === \"b\") {\n      this.gameOver();\n    }\n    else if (this.state.cellContents[cellIndex] === \"\") {\n      var neighboringCells = this.getNeighboringCells(cellIndex)\n\n      neighboringCells.forEach((neighborIndex) => {\n        if (this.state.cellContents[neighborIndex] !== \"b\") {\n          this.cellClick(neighborIndex);\n        }\n      });\n    }\n  }\n\n  gameOver() {\n    let cellCount = this.state.rowsNum * this.state.colsNum;\n\n    this.setState({\n      cellsRevealed: Array(cellCount).fill(true),\n    });\n  }\n  \n\n\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"header\">\n          {/* menu button here */}\n          <h1>Minesweeper</h1>\n        </header>\n        <div className=\"grid-wrapper\">\n          <main className=\"grid\" ref={this.gridRef}>\n            { this.renderGrid.bind(this)() }\n          </main>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}