{"version":3,"sources":["components/Cell.js","App.js","serviceWorker.js","index.js"],"names":["Cell","props","this","cellClicked","cellIndex","content","icon","faBomb","className","revealed","onClick","onCellClick","bind","renderContent","Component","App","setAsyncState","newState","Promise","resolve","setState","a","state","generateCellContents","cellsRevealed","newCellsRevealed","checkCell","cellsChecked","includes","cellContents","gameOver","cellCount","rowsNum","colsNum","aa","bb","newCellsChecked","push","bombCount","contentGenerated","gridRef","React","createRef","current","style","setProperty","Array","fill","cells","ii","key","protectedCellIndex","bombsPlaced","newCellContents","bombCell","Math","floor","random","bombsAroundCell","toString","ref","renderGrid","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"wYAoCeA,E,YA7Bb,WAAYC,GAAQ,qEACZA,I,2EAINC,KAAKD,MAAME,YAAYD,KAAKD,MAAMG,a,sCAIlC,MAA0B,KAAvBF,KAAKD,MAAMI,QACJ,KAEqB,MAAvBH,KAAKD,MAAMI,QACT,kBAAC,IAAD,CAAiBC,KAAMC,MAGvB,8BAAQL,KAAKD,MAAMI,W,+BAK7B,OACE,yBAAKG,UAAW,SAAWN,KAAKD,MAAMQ,SAAW,kBAAoB,IAAMC,QAASR,KAAKS,YAAYC,KAAKV,OACtGA,KAAKW,qB,GAxBIC,aCoQJC,E,YApQb,WAAYd,GAAQ,IAAD,8BACjB,4CAAMA,KAcRe,cAAgB,SAACC,GACf,OAAO,IAAIC,SAAQ,SAACC,GAAD,OAAa,EAAKC,SAASH,GAAU,kBAAME,WAhB7C,EA+InBhB,YA/ImB,uCA+IL,WAAOC,GAAP,eAAAiB,EAAA,yDAGP,EAAKC,MAAMC,qBAHJ,gCAIJ,EAAKA,qBAAqBnB,GAJtB,OAMV,EAAKgB,SAAS,CACZG,sBAAsB,IAPd,WAWgC,IAAxC,EAAKD,MAAME,cAAcpB,GAXjB,wBAYNqB,EAAmB,EAAKH,MAAME,eACjBpB,IAAa,EAbpB,SAcJ,EAAKY,cAAc,CACvBQ,cAAeC,IAfP,OAkBV,EAAKC,UAAUtB,GAlBL,4CA/IK,wDAqKnBsB,UArKmB,uCAqKP,WAAOtB,GAAP,qBAAAiB,EAAA,0DACN,EAAKC,MAAMK,aAAaC,SAASxB,GAD3B,yCAED,MAFC,UAIiC,MAAvC,EAAKkB,MAAMO,aAAazB,GAJlB,gBAKR,EAAK0B,WALG,0BAOsC,KAAvC,EAAKR,MAAMO,aAAazB,GAPvB,wBAQJ2B,EAAY,EAAKT,MAAMU,QAAU,EAAKV,MAAMW,QAC5CC,EAAK9B,EAAY,EAAKkB,MAAMW,QAC5BE,EAAK/B,EAAY,EAAKkB,MAAMW,SAE5BG,EAAkB,EAAKd,MAAMK,cACjBU,KAAKjC,GAbb,UAeF,EAAKY,cAAc,CACvBW,aAAcS,IAhBR,QAmBJF,EAAK,KACF9B,EAAY,GAAK,EAAKkB,MAAMW,UAAY,GACH,MAApC,EAAKX,MAAMO,aAAaK,EAAK,IAC/B,EAAK/B,YAAY+B,EAAK,GAIU,MAAhC,EAAKZ,MAAMO,aAAaK,IAC1B,EAAK/B,YAAY+B,IAGd9B,EAAY,GAAK,EAAKkB,MAAMW,UAAY,GACH,MAApC,EAAKX,MAAMO,aAAaK,EAAK,IAC/B,EAAK/B,YAAY+B,EAAK,KAKvB9B,EAAY,GAAK,EAAKkB,MAAMW,UAAY,GACI,MAA3C,EAAKX,MAAMO,aAAazB,EAAY,IACtC,EAAKD,YAAYC,EAAY,IAG5BA,EAAY,GAAK,EAAKkB,MAAMW,UAAY,GACI,MAA3C,EAAKX,MAAMO,aAAazB,EAAY,IACtC,EAAKD,YAAYC,EAAY,GAI7B+B,EAAKJ,KACF3B,EAAY,GAAK,EAAKkB,MAAMW,UAAY,GACH,MAApC,EAAKX,MAAMO,aAAaM,EAAK,IAC/B,EAAKhC,YAAYgC,EAAK,GAIU,MAAhC,EAAKb,MAAMO,aAAaM,IAC1B,EAAKhC,YAAYgC,IAGd/B,EAAY,GAAK,EAAKkB,MAAMW,UAAY,GACH,MAApC,EAAKX,MAAMO,aAAaM,EAAK,IAC/B,EAAKhC,YAAYgC,EAAK,IA7DpB,4CArKO,sDAEjB,EAAKb,MAAQ,CACXO,aAAc,GACdL,cAAe,GACfG,aAAc,GACdW,UAAW,GACXC,kBAAkB,EAClBN,QAAS,GACTD,QAAS,IAGX,EAAKQ,QAAUC,IAAMC,YAZJ,E,iFAoBjB,IAAIX,EAAY7B,KAAKoB,MAAMU,QAAU9B,KAAKoB,MAAMW,QAEhD/B,KAAKsC,QAAQG,QAAQC,MAAMC,YAAY,qBAAsB3C,KAAKoB,MAAMU,SACxE9B,KAAKsC,QAAQG,QAAQC,MAAMC,YAAY,sBAAuB3C,KAAKoB,MAAMW,SAEzE/B,KAAKkB,SAAS,CACZS,aAAciB,MAAMf,GAAWgB,KAAK,IACpCvB,cAAesB,MAAMf,GAAWgB,MAAK,O,mCAOvC,IAFA,IAAIC,EAAQ,GAEJC,EAAK,EAAGA,EAAM/C,KAAKoB,MAAMW,QAAU/B,KAAKoB,MAAMU,QAAUiB,IAC9DD,EAAMX,KAAK,kBAAC,EAAD,CAAMlC,YAAaD,KAAKC,YAAYS,KAAKV,MAAOG,QAASH,KAAKoB,MAAMO,aAAaoB,GAAKxC,SAAUP,KAAKoB,MAAME,cAAcyB,GAAK7C,UAAW6C,EAAIC,IAAKD,KAG/J,OAAOD,I,6CAQP,IAL6C,IAA1BG,EAAyB,uDAAN,KAClCpB,EAAY7B,KAAKoB,MAAMU,QAAU9B,KAAKoB,MAAMW,QAC5CmB,EAAc,EACdC,EAAkBP,MAAMf,GAAWgB,KAAK,IAEtCK,EAAclD,KAAKoB,MAAMgB,WAAW,CACxC,IAAIgB,EAAWC,KAAKC,MAAMD,KAAKE,SAAW1B,GAE1C,GAAkC,MAA9BsB,EAAgBC,GAClB,GAA2B,OAAvBH,EACFE,EAAgBC,GAAY,IAC5BF,QAEG,CACH,IAAIlB,EAAKiB,EAAqBjD,KAAKoB,MAAMW,QACrCE,EAAKgB,EAAqBjD,KAAKoB,MAAMW,QAEzC,GAAIqB,GAAYH,EACd,SAEF,GAAIjB,EAAK,EAAG,CACV,IAAKiB,EAAqB,GAAKjD,KAAKoB,MAAMW,UAAY,GAChDC,EAAK,IAAMoB,EACb,SAEJ,GAAIpB,IAAOoB,EACX,SAEA,IAAKH,EAAqB,GAAKjD,KAAKoB,MAAMW,UAAY,GAChDC,EAAK,IAAMoB,EACb,SAGN,IAAKH,EAAqB,GAAKjD,KAAKoB,MAAMW,UAAY,GAChDkB,EAAqB,IAAMG,EAC7B,SACJ,IAAKH,EAAqB,GAAKjD,KAAKoB,MAAMW,UAAY,GAChDkB,EAAqB,IAAMG,EAC7B,SAEJ,GAAInB,EAAKJ,EAAW,CAClB,IAAKoB,EAAqB,GAAKjD,KAAKoB,MAAMW,UAAY,GAChDE,EAAK,IAAMmB,EACb,SAEJ,GAAInB,IAAOmB,EACT,SAEF,IAAKH,EAAqB,GAAKjD,KAAKoB,MAAMW,UAAY,GAChDE,EAAK,IAAMmB,EACb,SAGND,EAAgBC,GAAY,IAC5BF,KAKN,IAAI,IAAIH,EAAK,EAAGA,EAAKlB,EAAWkB,IAAM,CACpC,IAAIS,EAAkB,EAClBxB,EAAKe,EAAK/C,KAAKoB,MAAMW,QACrBE,EAAKc,EAAK/C,KAAKoB,MAAMW,QAEG,MAAxBoB,EAAgBJ,KAGhBf,EAAK,KACFe,EAAK,GAAK/C,KAAKoB,MAAMW,UAAY,IACpCyB,GAA+C,MAA5BL,EAAgBnB,EAAK,GAAa,EAAI,GAE3DwB,GAA2C,MAAxBL,EAAgBnB,GAAc,EAAI,GAEhDe,EAAK,GAAK/C,KAAKoB,MAAMW,UAAY,IACpCyB,GAA+C,MAA5BL,EAAgBnB,EAAK,GAAa,EAAI,KAGxDe,EAAK,GAAK/C,KAAKoB,MAAMW,UAAY,IACpCyB,GAA+C,MAA5BL,EAAgBJ,EAAK,GAAa,EAAI,IACtDA,EAAK,GAAK/C,KAAKoB,MAAMW,UAAY,IACpCyB,GAA+C,MAA5BL,EAAgBJ,EAAK,GAAa,EAAI,GAEvDd,EAAKJ,KACFkB,EAAK,GAAK/C,KAAKoB,MAAMW,UAAY,IACpCyB,GAA+C,MAA5BL,EAAgBlB,EAAK,GAAa,EAAI,GAE3DuB,GAA2C,MAAxBL,EAAgBlB,GAAc,EAAI,GAEhDc,EAAK,GAAK/C,KAAKoB,MAAMW,UAAY,IACpCyB,GAA+C,MAA5BL,EAAgBlB,EAAK,GAAa,EAAI,IAGzDuB,EAAkB,IACpBL,EAAgBJ,GAAMS,EAAgBC,aAI1C,OAAOzD,KAAKc,cAAc,CACxBa,aAAcwB,M,iCA+FhB,IAAItB,EAAY7B,KAAKoB,MAAMU,QAAU9B,KAAKoB,MAAMW,QAEhD/B,KAAKkB,SAAS,CACZI,cAAesB,MAAMf,GAAWgB,MAAK,O,+BAOvC,OACE,yBAAKvC,UAAU,OACb,4BAAQA,UAAU,UAEhB,4CAEF,yBAAKA,UAAU,gBACb,0BAAMA,UAAU,OAAOoD,IAAK1D,KAAKsC,SAC7BtC,KAAK2D,WAAWjD,KAAKV,KAArBA,U,GA7PIY,aCOEgD,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.86f7aa83.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport './Cell.css';\n\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faBomb } from '@fortawesome/free-solid-svg-icons'\n\nclass Cell extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  onCellClick() {\n    this.props.cellClicked(this.props.cellIndex);\n  }\n\n  renderContent() {\n    if(this.props.content === \"\") {\n      return( null );\n    }\n    else if(this.props.content === \"b\") {\n      return( <FontAwesomeIcon icon={faBomb} /> );\n    }\n    else {\n      return( <span>{ this.props.content }</span> );\n    }\n  }\n\n  render() {\n    return(\n      <div className={\"cell \" + (this.props.revealed ? \"cell--revealed \" : \"\") } onClick={this.onCellClick.bind(this)}>\n        { this.renderContent() }\n      </div>\n    );\n  }\n}\n\nexport default Cell;","import React, { Component } from 'react';\nimport './App.css';\n\nimport Cell from \"./components/Cell.js\";\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      cellContents: [],\n      cellsRevealed: [],\n      cellsChecked: [],\n      bombCount: 40,\n      contentGenerated: false,\n      colsNum: 10,\n      rowsNum: 18,\n    };\n\n    this.gridRef = React.createRef();\n  }\n\n  setAsyncState = (newState) => {\n    return new Promise((resolve) => this.setState(newState, () => resolve()));\n  }\n\n  componentDidMount() {\n    let cellCount = this.state.rowsNum * this.state.colsNum;\n\n    this.gridRef.current.style.setProperty(\"--larger-dimension\", this.state.rowsNum);\n    this.gridRef.current.style.setProperty(\"--smaller-dimension\", this.state.colsNum);\n\n    this.setState({\n      cellContents: Array(cellCount).fill(\"\"),\n      cellsRevealed: Array(cellCount).fill(false),\n    });\n  }\n\n  renderGrid() {\n    var cells = [];\n\n    for(var ii = 0; ii < (this.state.colsNum * this.state.rowsNum); ii++) {\n      cells.push(<Cell cellClicked={this.cellClicked.bind(this)} content={this.state.cellContents[ii]} revealed={this.state.cellsRevealed[ii]} cellIndex={ii} key={ii} />);\n    }\n\n    return cells;\n  }\n\n  generateCellContents(protectedCellIndex=null) {\n    let cellCount = this.state.rowsNum * this.state.colsNum;\n    var bombsPlaced = 0;\n    var newCellContents = Array(cellCount).fill(\"\");\n\n    while(bombsPlaced < this.state.bombCount) {\n      let bombCell = Math.floor(Math.random() * cellCount);\n\n      if (newCellContents[bombCell] !== \"b\") {\n        if (protectedCellIndex === null) {\n          newCellContents[bombCell] = \"b\";\n          bombsPlaced++;\n        }\n        else {\n          var aa = protectedCellIndex - this.state.colsNum;\n          var bb = protectedCellIndex + this.state.colsNum;\n\n          if (bombCell == protectedCellIndex)\n            continue;\n  \n          if (aa > 0) {\n            if ((protectedCellIndex + 1) % this.state.colsNum !== 1)\n              if (aa - 1 === bombCell)\n                continue;\n    \n            if (aa === bombCell)\n            continue;\n    \n            if ((protectedCellIndex + 1) % this.state.colsNum !== 0)\n              if (aa + 1 === bombCell)\n                continue;\n          }\n    \n          if ((protectedCellIndex + 1) % this.state.colsNum !== 1)\n            if (protectedCellIndex - 1 === bombCell)\n              continue;\n          if ((protectedCellIndex + 1) % this.state.colsNum !== 0)\n            if (protectedCellIndex + 1 === bombCell)\n              continue;\n    \n          if (bb < cellCount) {\n            if ((protectedCellIndex + 1) % this.state.colsNum !== 1)\n              if (bb - 1 === bombCell)\n                continue;\n    \n            if (bb === bombCell)\n              continue;\n            \n            if ((protectedCellIndex + 1) % this.state.colsNum !== 0)\n              if (bb + 1 === bombCell)\n                continue;\n          }\n\n          newCellContents[bombCell] = \"b\";\n          bombsPlaced++;\n        }\n      }\n    }\n\n    for(var ii = 0; ii < cellCount; ii++) {\n      var bombsAroundCell = 0;\n      var aa = ii - this.state.colsNum;\n      var bb = ii + this.state.colsNum;\n\n      if (newCellContents[ii] === \"b\")\n        continue;\n\n      if (aa > 0) {\n        if ((ii + 1) % this.state.colsNum !== 1)\n          bombsAroundCell += newCellContents[aa - 1] === \"b\" ? 1 : 0;\n\n        bombsAroundCell += newCellContents[aa] === \"b\" ? 1 : 0;\n\n        if ((ii + 1) % this.state.colsNum !== 0)\n          bombsAroundCell += newCellContents[aa + 1] === \"b\" ? 1 : 0;\n      }\n\n      if ((ii + 1) % this.state.colsNum !== 1)\n        bombsAroundCell += newCellContents[ii - 1] === \"b\" ? 1 : 0;\n      if ((ii + 1) % this.state.colsNum !== 0)\n        bombsAroundCell += newCellContents[ii + 1] === \"b\" ? 1 : 0;\n\n      if (bb < cellCount) {\n        if ((ii + 1) % this.state.colsNum !== 1)\n          bombsAroundCell += newCellContents[bb - 1] === \"b\" ? 1 : 0;\n\n        bombsAroundCell += newCellContents[bb] === \"b\" ? 1 : 0;\n        \n        if ((ii + 1) % this.state.colsNum !== 0)\n          bombsAroundCell += newCellContents[bb + 1] === \"b\" ? 1 : 0;\n      }\n\n      if (bombsAroundCell > 0) {\n        newCellContents[ii] = bombsAroundCell.toString();\n      }\n    }\n\n    return this.setAsyncState({\n      cellContents: newCellContents,\n    });\n  }\n\n  cellClicked = async (cellIndex) => {\n    // console.log(this.state.cellContents[cellIndex]);\n\n    if (!this.state.generateCellContents) {\n      await this.generateCellContents(cellIndex);\n\n      this.setState({\n        generateCellContents: true,  \n      });\n    }\n\n    if (this.state.cellsRevealed[cellIndex] === false) {\n      var newCellsRevealed = this.state.cellsRevealed;\n      newCellsRevealed[cellIndex] = true;\n      await this.setAsyncState({\n        cellsRevealed: newCellsRevealed,\n      });\n\n      this.checkCell(cellIndex);\n    }\n  }\n\n  checkCell = async (cellIndex) => {\n    if (this.state.cellsChecked.includes(cellIndex))\n      return null;\n\n    if (this.state.cellContents[cellIndex] === \"b\") {\n      this.gameOver();\n    }\n    else if (this.state.cellContents[cellIndex] === \"\") {\n      let cellCount = this.state.rowsNum * this.state.colsNum;\n      var aa = cellIndex - this.state.colsNum;\n      var bb = cellIndex + this.state.colsNum;\n\n      var newCellsChecked = this.state.cellsChecked;\n      newCellsChecked.push(cellIndex);\n  \n      await this.setAsyncState({\n        cellsChecked: newCellsChecked,\n      });\n\n      if (aa > 0) {\n        if ((cellIndex + 1) % this.state.colsNum !== 1) {\n          if (this.state.cellContents[aa - 1] !== \"b\") {\n            this.cellClicked(aa - 1);\n          }\n        }\n\n        if (this.state.cellContents[aa] !== \"b\") {\n          this.cellClicked(aa);\n        }\n\n        if ((cellIndex + 1) % this.state.colsNum !== 0) {\n          if (this.state.cellContents[aa + 1] !== \"b\") {\n            this.cellClicked(aa + 1);\n          }\n        }\n      }\n\n      if ((cellIndex + 1) % this.state.colsNum !== 1) {\n        if (this.state.cellContents[cellIndex - 1] !== \"b\") {\n          this.cellClicked(cellIndex - 1);\n        }\n      }\n      if ((cellIndex + 1) % this.state.colsNum !== 0) {\n        if (this.state.cellContents[cellIndex + 1] !== \"b\") {\n          this.cellClicked(cellIndex + 1);\n        }\n      }\n\n      if (bb < cellCount) {\n        if ((cellIndex + 1) % this.state.colsNum !== 1) {\n          if (this.state.cellContents[bb - 1] !== \"b\") {\n            this.cellClicked(bb - 1);\n          }\n        }\n\n        if (this.state.cellContents[bb] !== \"b\") {\n          this.cellClicked(bb);\n        }\n        \n        if ((cellIndex + 1) % this.state.colsNum !== 0) {\n          if (this.state.cellContents[bb + 1] !== \"b\") {\n            this.cellClicked(bb + 1);\n          }\n        }\n      }\n    }\n  }\n\n  gameOver() {\n    let cellCount = this.state.rowsNum * this.state.colsNum;\n\n    this.setState({\n      cellsRevealed: Array(cellCount).fill(true),\n    });\n  }\n  \n\n\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"header\">\n          {/* menu button here */}\n          <h1>Minesweeper</h1>\n        </header>\n        <div className=\"grid-wrapper\">\n          <main className=\"grid\" ref={this.gridRef}>\n            { this.renderGrid.bind(this)() }\n          </main>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}